## Read read data using the new Epidata XML format into R

## Copyright (C) 2011 David Whiting

## This program is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 3 of the
## License, or (at your option) any later version.

## This program is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software Foundation,
## Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA


## PLEASE NOTE THAT I AM STILL EXPERIMENTING WITH THIS AND IT MIGHT
## NOT ALWAYS WORK.

## Version 1.0 by Jamie Hockin August 2012
## Future:  can we manage encrypted data?

unlink("STATUS.LOG")


status.log <- function(x) {
  ## Purpose: Simple logging mechanism. Can be useful for detecting bottlenecks etc.
  ## ----------------------------------------------------------------------
  ## Arguments: a message to be recorded in the log
  ## ----------------------------------------------------------------------
  ## Author: David Whiting, Date: 12 Jun 2011, 18:27
  right.now <- strftime(Sys.time(), format = "%Y-%m-%d %H:%M:%S") 
  cat(paste(right.now, x, "\n"), file = "STATUS.LOG", append = TRUE)
} 



extract.epidata.records <- function(rec, fields) {
  ## Purpose: Extract records from xml structure, allowing for missing fields.
  ## ----------------------------------------------------------------------
  ## Arguments: rec: a single record
  ## fields: a vector of field names (probably from the info table)
  ## ----------------------------------------------------------------------
  ## Author: David Whiting, Date: 12 Jun 2011, 19:59
  
  ## Changes: fields are now named in data records
  ##					xml treats whole record as a string
  ##					with separators = and , (\, is a string comma)
  
  rstatus <- sub("^rs","",xmlGetAttr(rec,"status"))
  ## special handling for escaped comma (\,) character in records
  d <- gsub("\\,","&comma;",xmlValue(rec),fixed=TRUE)
  ## split on commas and then on first = in each element of the list
  ## outer split first subs the first = to a comma so split
  d <- strsplit(sub("=","\\,",strsplit(d,",",fixed=TRUE)[[1]]),",",fixed=TRUE)
  nams <- unlist(lapply(d,"[",1))
  ## revert any escaped commas to simple text
  vals <- gsub("&comma;",",",unlist(lapply(d,"[",2)),fixed=TRUE)
  dd <- list()
  dd[nams] <- vals
  dd["rec.status"] <- rstatus
  names.of.missing.fields <- fields[!fields %in% names(dd)]
  if (length(names.of.missing.fields)) {
    num.missing.flds <- length(names.of.missing.fields)
    missing.flds <- rep(NA, num.missing.flds)
    names(missing.flds) <- names.of.missing.fields
    dd <- c(dd, missing.flds) 
  }
  ## Sort the fields so that they are all in the same order.
  dd <- dd[order(names(dd))]
  dd
}



### Get the records
epidata.records <- function(datfile, flds) {
  ## Purpose: Get the records from the XML file
  ## ----------------------------------------------------------------------
  ## Arguments: datfile: the DataFiles node from the XML file.
  ## flds: field information, as generated by fld.info()
  ## ----------------------------------------------------------------------
  ## 
  epi.records <- xmlChildren(datfile)[["Records"]]
  num.recs <- xmlSize(epi.records)
  recs <- xmlApply(epi.records, extract.epidata.records, flds)
  recs <- as.data.frame(do.call(rbind, recs))
  status.log(paste("Extracted", nrow(recs), "record(s)"))
  rownames(recs) <- NULL
  recs
}



convert.type <- function(x, fld.type, Settings) {
  ## Purpose: Convert from epidata to R data types
  ## ----------------------------------------------------------------------
  ## Arguments: x: a vector of values
  ## fld.type: the epidata type (a code number)
  ## Settings: settings information, as returned by epidata.meta.data()
  ## ----------------------------------------------------------------------
  ##
  
  ## Changes: field types now have text types
  if (fld.type %in% c("ftInteger","ftAutoInc")) {
    x <- as.numeric(as.character(x))
  } else if (fld.type %in% c("ftUpperString","ftString","internal")){
  	x <- as.character(x)
    ## Characters, do nothing
  } else if (fld.type == "ftFloat"){
    ## Decimal separator hack. It should convert to whatever R is using.
    levels(x) <- gsub("[,.]", Sys.localeconv()[['decimal_point']], levels(x))
    x <- as.numeric(as.character(x))
  } else if (fld.type %in% c("ftDMYDate","ftDMYAuto") ){
    ## 16/05/1968 (DD/MM/YYYY, i.e. 16th of May, 1968)
    dateFormat <- paste("%d", "%m", "%Y", sep = Settings$DateSeparator)
    x <- as.Date(x, dateFormat)
  } else if (fld.type %in% c("ftMDYDate","ftMDYAuto") ){
    ## 16/05/1968 (MM/DD/YYYY, i.e. May 16th, 1968)
    dateFormat <- paste("%m", "%d", "%Y", sep = Settings$DateSeparator)
    x <- as.Date(x, dateFormat)
  } else if (fld.type %in% c("ftYMDDate","ftYMDAuto") ){
    ## 16/05/1968 (YYYY/MM/DD, i.e. 1968, May 16th)
    dateFormat <- paste("%Y", "%m", "%d", sep = Settings$DateSeparator)
    x <- as.Date(x, dateFormat)
  } else if (fld.type %in% c("ftTime","ftTimeAuto") ){
    ## Time fields. At the moment it sets the date part to the current date.
    timeFormat <- paste("%H", "%M", "%S", sep = Settings$TimeSeparator)
    x <- as.POSIXct(strptime(x, timeFormat))
  } else if (fld.type == "ftBoolean"){
    ## Logical - empty to NA, Y to TRUE, else to FALSE
    x <- as.character(x)
    x[x == ""] <- NA
    x <- x == "Y"
  } else {
    status.log(paste("Field type not handled:", fld.type))
  }
  x
}



epidata.apply.field.structure <- function(sections, dat, Settings, keep.deleted) {
  ## Purpose: Apply the field definition information to each field
  ## ----------------------------------------------------------------------
  ## Arguments: sections: sections node from the XML file (these are
  ## sections of the data entry screen.
  ## dat: a dataframe of records that have been extracted from the XML file.
  ## Settings: settings information, as returned by epidata.meta.data()
  ## ----------------------------------------------------------------------
  ## 
  
  ## Changes: more field info now stored as attributes
  ##					field name as id
  ##					field type as type, length, decimals
  ##					field id does not exist so use lower case field name
  
  num.sections <- xmlSize(xmlChildren(sections))
  
  for (si in 1:num.sections) {
    fields <- xmlChildren(xmlChildren(sections)[[si]])[["Fields"]]
    num.flds <- xmlSize(fields)
    status.log(paste("Section",si,"has",num.flds,"fields"))   
    for (i in 1:num.flds) {
      field <- xmlChildren(fields)[[i]]
 			fld.attrs <- xmlAttrs(field)
 			fld.id <- fld.attrs[["id"]]
 			fld.name <- tolower(fld.id)
 			fld.type <- fld.attrs[["type"]]
    
      fld <- which(names(dat) == fld.id)
      names(dat)[fld] <- fld.name
      dat[, fld] <- convert.type(dat[, fld], fld.type, Settings)
    }
  }
  ## pass record status through convert to ensure it returns as character data
  fld <- which(names(dat) == "rec.status")
  dat[, fld] <- convert.type(dat[, fld],"internal",Settings)
  if (!keep.deleted) {
  	dat <- dat[!dat[, fld]=="Deleted",]
  }
  dat
}



number.of.records <- function (num.recs) {
  ## Purpose: Filter records as they are parsed.
  ## ----------------------------------------------------------------------
  ## Arguments: x: I'm not really sure if this is used.
  ## num.recs: the number of records that we want
  ## ----------------------------------------------------------------------
  ## Details: I'm still trying to get my head around handlers. I am
  ## hoping that by breaking them out like this I will begin to
  ## understand them better. 
  ## ----------------------------------------------------------------------
  ##
  cnt <- 0
  list(Record =
       function (x, num = num.recs, ...) {
         retval <- NULL
         cnt <<- cnt + 1
         if (cnt <= num) retval <- x
         retval
       })
}




read.epidata.xml <- function(x,
                             use.epidata.labels = TRUE,
                             set.missing.na = TRUE,
														 keep.deleted,
                             random.pc = NULL,
                             num.recs = NULL) {
  ## Purpose: Main user function to read in the XML file.
  ## ----------------------------------------------------------------------
  ## Arguments: x: the name of an XML file.
  ## use.epidata.labels: If FALSE do not use the epidata value labels.
  ## set.missing.na: if TRUE (the default) use the epidata definition
  ##  of missing values and set the value in R to NA. Epidata allows
  ##  for more than one definition of missing value, and all of these
  ##  will be mapped to NA.
  ## keep.deleted: if any value is specified, deleted records will be kept;
  ##  default is to drop deleted records
  ## random.pc: a number from 0 to 100 specifying the percentage of
  ##  records that should be imported. Records are selected
  ##  randomly. If the value is 0, no records will be imported, only
  ##  the metadata.
  ## num.recs: A number of records to import. Records are imported
  ##  sequentially until num.recs is reached. If both random.pc and
  ##  num.recs are specified only random.pc will be used.
  ## ----------------------------------------------------------------------
  ## Author: David Whiting, Date: 12 Jun 2011, 18:27
  
  ## Changes: meta data has changed
  
  require(XML)
  t1 <- Sys.time()
  status.log(paste("Reading", x))
  if (missing(keep.deleted)) {
  	status.log("Deleted records will be dropped")
  } else {
  	status.log("Deleted records will be kept")
  }

  y <- list()
  y[['filename']] <- x
  if (!is.null(random.pc)) {
    ## Take a random sample of records.
    status.log(paste(">>> Taking a", random.pc, "% random sample of records."))
    x <- xmlTreeParse(x, handlers = list(Record =
                           function (x, pc = random.pc, ...) {
                             retval <- NULL
                             randval <- runif(1)
                             limit <- pc / 100
                             if (randval < limit) retval <- x
                             retval
                           }
                           ), asTree = TRUE)
  } else if (!is.null(num.recs)) {
    ## Take a specified number of records from the beginning of the record set.
    x <- xmlTreeParse(x, handlers = number.of.records(num.recs), asTree = TRUE)
  } else {
    ## Take all the records.
    x <- xmlTreeParse(x)
  }
  epidata <- xmlRoot(x)
  x.fld.info <- fld.info(epidata)
 
  y[['Settings']] <- epidata.meta.data(epidata, "Settings")

  ## Get the data files
  num.datafiles <- xmlSize(xmlChildren(epidata)[["DataFiles"]])
  status.log(paste("Found",num.datafiles,"data file(s)"))
  for (i in 1:num.datafiles) {
    datfile <- xmlChildren(xmlChildren(epidata)[["DataFiles"]])[[i]]
    datfile.name <- xmlAttrs(datfile)[["id"]]
    sections <- xmlChildren(datfile)[["Sections"]]
    
    dat1 <- epidata.records(datfile, x.fld.info$id)

    if (nrow(dat1) > 0) {
      dat1 <- epidata.apply.field.structure(sections, dat1, y$Settings,!missing(keep.deleted))
         	
      y$data[i] <- list(dat1)
      names(y$data)[i] <- datfile.name
     }
  }

  y[['field.info']] <- x.fld.info
  y[['labels']] <- get.epidata.value.labels(epidata, y$Settings)
  y[['Study']] <- epidata.meta.data(epidata, "StudyInfo")

  if (use.epidata.labels & "data" %in% names(y)) {
    status.log("Use epidata labels")
    y <- use.epidata.labels(y, set.missing.na)
  }
  duration <- round(as.numeric(difftime(Sys.time(), t1), units = "secs"), 1)
  status.log(paste("Finished in", duration, "seconds."))
  y
}



epidata.meta.data <- function(x, tag) {
  ## Purpose: Get the epidata settings information
  ## ----------------------------------------------------------------------
  ## Arguments: x: an xmlRoot()
  ## ----------------------------------------------------------------------
  ## Author: David Whiting, Date: 12 Jun 2011, 18:27
  
  ## Changes: useful settings are now attributes of Settings tag
  
  y <- list()
  these.data <- xmlElementsByTagName(x, tag, rec = TRUE)[[tag]]
  if (tag=="Settings") {
  	for (i in 1:xmlSize(these.data)) {
  		y["dateSeparator"] <- xmlAttrs(these.data)[["dateSeparator"]]
  		y["timeSeparator"] <- xmlAttrs(these.data)[["timeSeparator"]]
  		y["decimalSeparator"] <- xmlAttrs(these.data)[["decimalSeparator"]]
  	}
  }
  else {
		for (i in 1:xmlSize(these.data)) {
			dd <- xmlValue(xmlChildren(these.data)[[i]])
			if (length(dd) == 0) dd <- ""
			y[xmlName(xmlChildren(these.data)[[i]])] <- dd
		}
  }
  y
}






fld.info <- function(x) {
  ## Purpose: Create a table of info about the fields
  ## ----------------------------------------------------------------------
  ## Arguments: x: an xmlRoot() 
  ## ----------------------------------------------------------------------
  ## Author: David Whiting, Date: 12 Jun 2011, 18:26
  
  ## Changes: field parameters are now presented as attributes
 
  y <- xmlElementsByTagName(x, "Field", rec = TRUE)

  ## start with definition of record status
  fld.id <- "rec.status"
  fld.name <- "rec.status"
  fld.type <- "internal"
  fld.length <- NA
  fld.decimals <- NA
  fld.question <- "Deleted"
  fld.valuelabel <- NA
  for (i in 1:xmlSize(y)) {
  	fld.attr <- xmlAttrs(y[[i]])
    fld.id <- c(fld.id, fld.attr[["id"]])
    fld.name <- c(fld.name, tolower(fld.attr[["id"]]))
    fld.type <- c(fld.type, fld.attr[["type"]])
    fld.length <- c(fld.length, fld.attr[["length"]])
    fld.decimals <- c(fld.decimals, fld.attr[["decimals"]])
    fld.question <- c(fld.question, xmlValue(xmlChildren(y[[i]])[["Question"]]))
    fld.valuelabel <- c(fld.valuelabel, fld.attr["valueLabelRef"][[1]]) ## optional
  }
  data.frame(id = fld.id,
             name = fld.name,
             type = fld.type,
             length = fld.length,
             decimals = fld.decimals, 
             question = fld.question,
             value.labelset = fld.valuelabel)
}




get.epidata.value.labels <- function(x, Settings) {
  ## Purpose: Create a list of epidata labels
  ## ----------------------------------------------------------------------
  ## Arguments: x: an xmlRoot
  ## ----------------------------------------------------------------------
  ## Author: David Whiting, Date: 14 Jun 2011, 20:26
  ## ----------------------------------------------------------------------
  
  ## Changes: new label structure
  
  y <- xmlElementsByTagName(x, "ValueLabelSet", rec = TRUE)
  if (xmlSize(y) == 0) return(NULL)
  i <- 1
  value.labels <- list()
  for (i in 1:xmlSize(y)) {
    this.valueset <- y[[i]]
    valueset.id <- xmlAttrs(this.valueset)[["id"]]
    valueset.type <- xmlAttrs(this.valueset)[["type"]]
    j <- 1
    this.value <- NULL
    this.order <- NULL
    this.label <- NULL
    this.missing <- NULL
    for (j in 1:xmlSize(this.valueset[['Internal']])) {
      this.value <- c(this.value, xmlAttrs(this.valueset[["Internal"]][[j]])[["value"]])
      this.order <-   c(this.order,   xmlAttrs(this.valueset[["Internal"]][[j]])[["order"]])
      ## Find out if missing exists
      if ("missing" %in% names(xmlAttrs(this.valueset[["Internal"]][[j]]))) {
        ## Convert this to a logical variable.
        this.missing <- c(this.missing, xmlAttrs(this.valueset[["Internal"]][[j]])[["missing"]] == "true")
      } else {
        this.missing <- c(this.missing, FALSE)
      }
      this.label <- c(this.label, xmlValue(this.valueset[["Internal"]][[j]][["Label"]]))
    }
    ## Convert the value to the right data type
    this.value <- convert.type(factor(this.value), valueset.type, Settings)
    these.labels <- data.frame(value = this.value, order = this.order, label = this.label, missing = this.missing)
    these.labels <- list(name = valueset.id,
                         type = valueset.type,
                         labels = these.labels)
    value.labels[valueset.id] <- list(these.labels)
  }
  value.labels
}


is.epidata.na <- function(x, value.labels, label.set) {
  ## Purpose: Determine if a value is missing or not
  ## ----------------------------------------------------------------------
  ## Arguments: x: a vector of values
  ## value.labels: a list of value labels created by get.epidata.value.labels()
  ## label.set: the name of a set of labels.
  ## ----------------------------------------------------------------------
  ## Returns: a logical vector (TRUE/FALSE)
  ## ----------------------------------------------------------------------
  ## Author: David Whiting, Date: 14 Jun 2011, 20:26

  retval <- NULL
  for (j in 1:length(x)) {
    if (is.na(x[j])) {
      this.val <- NA
    } else {
      i <- as.character(value.labels[[label.set]]$labels$value) == as.character(x[j])
      this.val <- value.labels[[label.set]]$labels$missing[i]
    }
    retval <- c(retval, this.val)
  }
  retval
}




epidata.value.label <- function(x, value.labels, label.set) {
  ## Purpose: Return the value label for a given value
  ## ----------------------------------------------------------------------
  ## Arguments: x: a vector of values
  ## value.labels: a list of value labels created by get.epidata.value.labels()
  ## label.set: the name of a set of labels.
  ## ----------------------------------------------------------------------
  ## Returns: a factor vector of value labels for a given values
  ## ----------------------------------------------------------------------
  ## Author: David Whiting, Date: 14 Jun 2011, 20:26

  retval <- NULL
  missing.levels <- NULL
  for (j in 1:length(x)) {
    if (is.na(x[j])) {
      this.val <- NA
    } else {
      i <- as.character(value.labels[[label.set]]$labels$value) == as.character(x[j])
      if (any(i)) {
        this.val <- as.character(value.labels[[label.set]]$labels$label[i])
      } else {
        missing.levels <- unique(c(missing.levels, as.character(x[j])))
        this.val <- as.character(x[j])
      }
    }
    retval <- c(retval, this.val)
  }
  if (!is.null(missing.levels)) {
    missing.levels <- paste(missing.levels, collapse = ", ")
    status.log(paste("Levels missing in label set ",  label.set, ": ", missing.levels, sep = ""))
  }
  as.factor(retval)
}



use.epidata.labels <- function(x, set.missing.na = TRUE) {
  ## Purpose: Recode the data using the epidata value labels
  ## ----------------------------------------------------------------------
  ## Arguments: x: an imported object with data and field info
  ## ----------------------------------------------------------------------
  ## Author: David Whiting, Date: 14 Jun 2011, 20:26
  ## ----------------------------------------------------------------------
  for (i in 1:nrow(x$field.info)) {
    if (!is.na(x$field.info$value.labelset)[i]) {
      this.labelset <- x$field.info$value.labelset[i]
      this.field <- x$field.info$name[i]
      ## This is a bit clumsy, but I had to break it down to get my head
      ## around it.
      j <- which(names(x$data[[1]]) == this.field)
      dd <- x$data[[1]][, j]
      ## Mark the missing values first
      if (set.missing.na) dd[is.epidata.na(dd, x$labels, this.labelset)] <- NA
      ## Relabel the values.
      dd <- epidata.value.label(dd, x$labels, this.labelset)
      x$data[[1]][, j] <- dd
    }
  }
  x
}



